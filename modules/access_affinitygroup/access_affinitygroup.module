<?php

/**
 * @file
 * Module for affinity group.
 *
 * Each affinity group (AG) has a dedicated "List" in Constant Contact, and
 * each user is a Constant Contact (CC) "Contact".
 * We add a user to CC when the user logs in, if they don't already have a
 * constant contact id stored on the user form.
 * When a user Joins or Leaves an AG, we add or remove the user from
 * the corresponding CC list.
 * When an AG is edited or created, we add the list to CC if not already done.
 * Each AG should have a 'list_id' item that was generated by CC.
 * Note: The list in Constant Contact is stored by the AG name, so relationship
 * to CC list is broken if AG name changes.
 *
 * Code in this module also implements the following:
 *  - Coordinators for Affinity Groups have their
 *    "Affinity Group Leader" role updated
 *  - Whenever an Affinity Group is saved, a taxonomy term with the same
 *    name is created.
 *
 * Note: dependency on title of 'ACCESS Support' Affinity group. Change code if
 * title changes.
 */

use GuzzleHttp\Client;
use Drupal\node\Entity\Node;
use Drupal\access_affinitygroup\Plugin\ConstantContactApi;
use Drupal\Component\Utility\Xss;
use Drupal\Component\Serialization\Json;
use Drupal\Core\Entity\EntityInterface;
use Drupal\taxonomy\Entity\Term;
use Drupal\user\Entity\User;
use Drupal\user\UserInterface;
use Drupal\views\ViewExecutable;

// For devtest, put in front of emails and uname for dev; set to '' to use real names.
const cDevUname = '';
const cAccessEmail = "supportapiaccess@access-ci.org";

// cCronCheckInterval: true for production so cron just runs once/night;
// For dev purposes, set false to run cron cider import on demand.
// Dev can also completely disable/force the cron from the module's admin config page.
const cCronCheckInterval = TRUE;
// Const cCronCheckInterval = false;.
// Global for collectCronLog for dev status email.
$logCronErrors = [];
// Global for collectCronLog for dev status email.
$logCronInfo = [];

/**
 * Implements hook_entity_presave().
 * Handles either
 *  case 1) User clicked Join flag on Affinity Group:
 *    We call api to add user to corresponding email list.
 *
 *   Join and Leave AG are implemented using a drupal Flag. Each AG
 *   has a corresponding flag that can be set per-user, signifying
 *   whether the user belongs to the AG.
 *
 *  case 2) Admin user saved Affinity Group form:
 *    If the AG does not already have a list_id from CC,
 *    we call api to create the email list,
 *    update AG Leader roles for added or removed coordinators,
 *    Ensure every Affinity Group name has a corresponding taxonomy term.
 *
 */
function access_affinitygroup_entity_presave(EntityInterface $entity) {
  $type = $entity->bundle();
  if ($type == 'affinity_group') {

    if (method_exists($entity, 'getFlaggableType')) {
      // case 1: User did Join the AG (using the Join button or link)

      // Exit if CRON because this hook assumes there is a current user.
      if (\Drupal::state()->get('access_affinitygroup.cronrunning', FALSE)) {
        return;
      }

      // The flag sits on a taxonomy; the taxonomy id is used to find the AG node
      // which we need to build the JSON to send to api.
      $taxonomyId = $entity->get('entity_id')->getValue()[0]['value'];
      $currentUser = \Drupal::currentUser();
      $userId = $currentUser->id();
      $userDetails = User::load($userId);
      subscribeToCCList($taxonomyId, $userDetails);

      // If present, remove this AG from this user's block list.
      removeBlockedAG($taxonomyId, $userDetails);
    }
    else {
      // case 2: Affinity group edit was saved by admin user.
      update_ag_leader_roles($entity);
      add_ag_taxonomy_term($entity);

      // If not already there, add list to constant contact.
      // get all existing lists.
      $cca = new ConstantContactApi();
      $lists = $cca->apiCall('/contact_lists ');
      if (empty($lists)) {
        return;
      }

      // Debug info: here you can see all lists CC knows about along with their List IDs
      // kint($lists);
      // look for this AG in the list of CC lists (title== listname)
      $title = $entity->getTitle();
      $list_exists = FALSE;
      foreach ($lists->lists as $list) {
        if ($list->name == $title) {
          $list_exists = TRUE;
          break;
        }
      }
      // We didn't find an email list id for this AG - make it now.
      if (!$list_exists) {
        $get_fields = $entity->getFields();
        $summary = $get_fields['body']->summary;
        // Api max is 255 characters.
        $summary = (strlen($summary) > 255) ? substr($summary, 0, 255) : $summary;
        $post_data = [
          'name' => $title,
          'favorite' => 0,
          'description' => $summary,
        ];
        $post_data = json_encode($post_data);

        // Create Constant contact list named with AG title.
        $created_list = $cca->apiCall('/contact_lists ', $post_data, 'POST');

        if (!empty($created_list)) {
          $list_id = Xss::filter($created_list->list_id);
        }

        if (!empty($list_id)) {
          $entity->set('field_list_id', $list_id);
        }
        else {
          showStatus('Bad Constant Contact list id.');
        }
      }
    }
  }
}

/**
 * Implements hook_views_pre_render().
 *
 * Used in this case to add the CiDeR resource titles & descriptions to the view.
 *
 * The affinity group view has a custom text field that drupal labeled
 * 'nothing' -- this function updates that field with html listing any associated
 * CiDeR resources, both their title & description.
 */
function access_affinitygroup_views_pre_render(ViewExecutable $view)
{
  if ($view->id() == 'affinity_group' && $view->current_display == 'group') {

    foreach ($view->result as $value) {

      $cider_ids = $value->_entity->get('field_cider_resources')->getValue();
      $node_storage = \Drupal::entityTypeManager()->getStorage('node');
      $cider_text = '';

      foreach ($cider_ids as $cider_id) {
        $node = $node_storage->load($cider_id['target_id']);
        $cider_text .= '<h3>' . $node->get('title')->value . '</h3><p>'
            . $node->get('body')->value . '</p>';
      }

      foreach ($view->field as $id => $field) {
        if ($id == 'nothing') {
            $field->options['alter']['text'] = $cider_text;
        }
      }
    }
  }
}


/**
 * - update AG Leader roles for added or removed coordinators.
 */
function update_ag_leader_roles($entity) {
  // Get all coordinators for this AG.
  $coordinators = $entity->get('field_coordinator')->getValue();

  // Add 'affinity_group_leader' role to all coordinators.
  $coordinator_ids = [];
  foreach ($coordinators as $coordinator) {
    $coordinator_id = $coordinator['target_id'];
    $coordinator_ids[] = $coordinator_id;
    $user = User::load($coordinator_id);

    $user->addRole('affinity_group_leader');
    $user->save();
  }

  // If removing a coordinator, remove the leader role (if not a leader anywhere else)
  update_removed_ag_leader_roles($entity, $coordinator_ids);
}

/**
 *
 */
function update_removed_ag_leader_roles($entity, $coordinator_ids) {
  // Get the original list of coordinators.
  $original_coordinators = $entity->original
    ? $entity->original->get('field_coordinator')->getValue()
    : NULL;

  // Build an array of all removed coordinators.
  $removed_coordinator_ids = [];
  foreach ($original_coordinators as $original_coordinator) {
    $original_coordinator_id = $original_coordinator['target_id'];
    if (!in_array($original_coordinator_id, $coordinator_ids)) {
      $removed_coordinator_ids[] = $original_coordinator_id;

      // $msg = "user id $original_coordinator_id removed";
      // \Drupal::messenger()->addStatus($msg);
    }
  }

  // If any coordinators removed, possibly remove their leader role.
  if (count($removed_coordinator_ids)) {

    // Get all affinity group coordinators on other affinity groups.
    $storage = \Drupal::service('entity_type.manager')->getStorage('node');
    $all_affinity_groups = $storage->loadByProperties([
      'type' => 'affinity_group',
    ]);

    $all_other_coordinator_ids = [];

    foreach ($all_affinity_groups as $affinity_group) {

      if ($entity->id() == $affinity_group->id()) {
        // \Drupal::messenger()->addStatus('in possibly remove, skipping group id = ' . $entity->id());
        continue;
      }
      $coordinators = $affinity_group->get('field_coordinator')->getValue();
      foreach ($coordinators as $coordinator) {
        $all_other_coordinator_ids[] = $coordinator['target_id'];
        ;
      }
    }

    // \Drupal::messenger()->addStatus('all other ag coord ids = ' . print_r($all_other_coordinator_ids, true));
    // \Drupal::messenger()->addStatus('all removed coord ids = ' . print_r($removed_coordinator_ids, true));
    // Foreach removed coordinator,
    //    if not a coordinator on any other affinity group,
    //       remove the leader role.
    foreach ($removed_coordinator_ids as $removed_coordinator_id) {
      $user = User::load($removed_coordinator_id);
      if (!in_array($removed_coordinator_id, $all_other_coordinator_ids)) {
        $user->removeRole('affinity_group_leader');
        $user->save();
        \Drupal::messenger()->addStatus('Removed Affinity Group Leader role for ' . $user->getAccountName());
      }
      else {
        \Drupal::messenger()->addStatus('Not removing Affinity Group Leader role for ' . $user->getAccountName()
          . ' because coordinator for another Affinity Group');
      }
    }
  }
}

/**
 *
 */
function add_ag_taxonomy_term($entity) {
  $ag_title = $entity->getTitle();
  $exists = !empty(ag_taxonomy_lookup($ag_title));
  $tid = NULL;
  if ($exists) {
    $tid = array_keys(ag_taxonomy_lookup($ag_title))[0];
  }
  else {
    $tid = create_ag_taxonomy_term($ag_title);
  }

  // Set entity's field_affinity_group to new term.
  $entity->set('field_affinity_group', $tid);
}

/**
 *
 */
function ag_taxonomy_lookup($ag_title) {
  // Ok to pass null -- returns null if $ag_title is null.
  $lookup = taxonomy_term_load_multiple_by_name($ag_title, 'affinity_groups');
  return $lookup;
}

/**
 *
 */
function create_ag_taxonomy_term($ag_title) {
  $term = Term::create([
    'vid' => 'affinity_groups',
    'name' => $ag_title,
  ]);
  $term->save();
  return $term->tid->value;
}

/**
 * Call CC API to add user to the email list corresponding to the entityId.
 */
function subscribeToCCList($taxonomyId, $userDetails) {
  $postJSON = makeListMembershipJSON($taxonomyId, $userDetails);
  if (empty($postJSON)) {
    showStatus("Can't add user to email list; check if user is missing Constant Contact ID.");
  }
  else {
    $cca = new ConstantContactApi();
    $ccResponse = $cca->apiCall('/activities/add_list_memberships', $postJSON, 'POST');
  }
}

/**
 * Implements hook_entity_delete().
 * * Handles either
 *   Case 1) User did Leave on Affinity Group
 *    Remove user from the email list.
 *   Case 2) Admin deleted Affinity Group
 *    Delete the corresponding CC email list.
 *
 * See notes above on presave for Join flag for Leave.
 */
function access_affinitygroup_entity_delete(EntityInterface $entity) {
  $type = $entity->bundle();
  if ($type == 'affinity_group') {

    if (method_exists($entity, 'getFlaggableType')) {

      // case 1: User did Leave AG. This flag is related to a taxonomy; the taxonomy
      // id is used to find the AG node related to the taxonomy and then the CC
      // list_id within the node for json to send to api.
      $taxonomyId = $entity->get('entity_id')->getValue()[0]['value'];
      // $refEntArray = $entity->referencedEntities();
      $currentUser = \Drupal::currentUser();
      $userId = $currentUser->id();
      $userDetails = User::load($userId);

      $postJSON = makeListMembershipJSON($taxonomyId, $userDetails);
      if (!empty($postJSON)) {
        $cca = new ConstantContactApi();
        $ccResponse = $cca->apiCall('/activities/remove_list_memberships', $postJSON, 'POST');
      }
      // Put this AG on this user's block list if not already there.
      addBlockedAG($taxonomyId, $userDetails);

    }
    else {
      // case 2: AG getting deleted.
      $title = $entity->getTitle();
      $cca = new ConstantContactApi();
      $lists = $cca->apiCall('/contact_lists');
      $list_exists = FALSE;
      foreach ($lists->lists as $list) {
        if ($list->name == $title) {
          // Constant Contact contains affinity group
          // title in list.
          $list_id = $list->list_id;
          break;
        }
      }

      if (isset($list_id)) {
        $post_data = [
          'list_id' => $list_id,
        ];
        $post_data = json_encode($post_data);
        $cca->apiCall("/contact_lists/$list_id", $list_id, 'DELETE');
      }
    }
  }
}

/**
 * User is leaving an ag; add to, if not already on, blocked list.
 */
function addBlockedAG($agTaxonomyId, $userDetails) {
  $userBlockedAgTids = [];
  $userBlockedArray = $userDetails->get('field_blocked_ag_tax')->getValue();
  foreach ($userBlockedArray as $userBlock) {
    $userBlockedAgTids[] = $userBlock['target_id'];
  }

  if (!in_array($agTaxonomyId, $userBlockedAgTids)) {
    $userDetails->get('field_blocked_ag_tax')->appendItem($agTaxonomyId);
    $userDetails->save();
  }
}

/**
 * User is joining an ag; remove if on the blocked list.
 */
function removeBlockedAG($agTaxonomyId, $userDetails) {
  $userBlockedTaxIds = [];
  // Make list minus the newly joined ag.
  $userBlockedArray = $userDetails->get('field_blocked_ag_tax')->getValue();
  $wasBlocked = FALSE;
  foreach ($userBlockedArray as $userBlock) {
    if ($userBlock['target_id'] !== $agTaxonomyId) {
      $userBlockedTaxIds[] = $userBlock['target_id'];
    }
    else {
      $wasBlocked = TRUE;
    }
  }

  // Update the user with fresh block list only if ag was on block list.
  if ($wasBlocked) {
    $userDetails->set('field_blocked_ag_tax', $userBlockedTaxIds);
    $userDetails->save();
  }
}

/**
 * Prepares json for api call that for adds or deletes CC user from
 * a CC list.  The json contains 2 CC ids: the user (contact) and the
 * list id.
 * Called from code where we have the entity id of the Join/Leave flag
 * corresponding to the Affinity Group. We use this entity id to find the
 * node (AG) containing the CC list id.
 */
function makeListMembershipJSON($flagEntityId, $userDetails) {
  $ccIdField = $userDetails->get('field_constant_contact_id')->getValue();
  if (!empty($ccIdField)) {
    $user_cc_id = $ccIdField[0]['value'];
  }

  if (empty($user_cc_id)) {
    return NULL;
  }

  // Find the AG node that stores the entity Id of the flag; that
  // is the one and only AG that corresponds to this flag.
  $query = \Drupal::entityQuery('node');
  $node_ids = $query
    ->condition('field_affinity_group', $flagEntityId)
    ->execute();

  $aval = array_values($node_ids);
  $nid = $aval[0];

  $ag = Node::load($nid);

  // Finally we can get out the CC list id stored in the AG node.
  $fieldVal = $ag->get('field_list_id')->getValue();
  if (!empty($fieldVal)) {
    $list_cc_id = $fieldVal[0]['value'];
    ;
  }

  if (empty($list_cc_id)) {
    showStatus('Missing Constant Contact List Id for this Affinity Group.');
    return NULL;
  }

  $post_data = [
    'source' => [
      'contact_ids' => [$user_cc_id],
    ],
    'list_ids' => [$list_cc_id],
  ];
  $post_data = json_encode($post_data);
  return $post_data;
}

/**
 * Implements hook_user_login().
 * Add user to Constant Contact if we don't have a CC ID stored yet.
 */
function access_affinitygroup_user_login(UserInterface $account) {
  $current_user = \Drupal::currentUser();

  $user_id = $current_user->id();
  $user_detail = User::load($user_id);

  $cca_user_id = NULL;
  $field_val = $user_detail->get('field_constant_contact_id')->getValue();
  if (!empty($field_val)) {
    $cca_user_id = $field_val[0]['value'];
  }
  // If user did not already have the CC id, try to add to CC.
  if (empty($cca_user_id)) {

    $firstName = $user_detail->get('field_user_first_name')->getString();
    $lastName = $user_detail->get('field_user_last_name')->getString();

    $cca_user_id = addUserToConstantContact($current_user->getEmail(), $firstName, $lastName);
    if (empty($cca_user_id)) {
      showStatus("Could not add user to Constant Contact.");
    }
    else {
      $user_detail->set('field_constant_contact_id', $cca_user_id);
      $user_detail->save();
    }
  }
  else {
    // This else just for debugging in early stages
    // showStatus("Login and NOT attempting add of new constant contact id.");.
  }
}

/**
 * Return the new ID if any.
 */
function addUserToConstantContact($userEmail, $firstName, $lastName) {
  $cca = new ConstantContactApi();
  $ccaUserId = $cca->addContact($firstName, $lastName, $userEmail);
  return $ccaUserId;
}

/**
 *
 */
function showStatus($logmsg) {
  \Drupal::messenger()->addStatus($logmsg);
}

/**
 * Implements hook_cron().
 * Two functions:
 * 1) Refreshes the authorization. If not run, token expires and we'll get
 * 'not authorized' return code from api calls.
 * 2) User Allocations Import
 */
function access_affinitygroup_cron() {
  try {
    \Drupal::state()->set('access_affinitygroup.cronrunning', FALSE);
    // 1. Refresh the Constant Contact Token
    if (shouldRun('token')) {
      $currentTime = \Drupal::time()->getCurrentTime();
      \Drupal::state()->set('access_affinitygroup.crontime-t', $currentTime);
      collectCronLog('Running cron: token' . date("Y-m-d H:i:s", $currentTime), 'i');

      $cca = new ConstantContactApi();
      $cca->newToken();
    }

    // 2. call xdusage api to get users and create/update their
    // allocations and associated affinity groups.
    if (shouldRun('users')) {
      \Drupal::state()->set('access_affinitygroup.cronrunning', TRUE);
      $currentTime = \Drupal::time()->getCurrentTime();
      \Drupal::state()->set('access_affinitygroup.crontime-u', $currentTime);
      collectCronLog('Running cron: user' . date("Y-m-d H:i:s", $currentTime), 'i');

      updateUserAllocations();
      // emailDevCronLog(); // this function needs to be fixed
    }
  }
  catch (Exception $e) {
    collectCronLog('exception: ' . $e->getMessage());
  }  finally {
    \Drupal::state()->set('access_affinitygroup.cronrunning', FALSE);
  }
}

/**
 * Test if the cron function should run: either 'token' for refresh cc token,
 * or 'users' for running the allocations api.
 * we might read from module config file in future to see if function disabled.
 */
function shouldRun($function) {

  $currentTime = \Drupal::time()->getCurrentTime();
  if ($function == 'token') {
    $lastRun = \Drupal::state()->get('access_affinitygroup.crontime-t', 0);
    $hoursDiff = round(($currentTime - $lastRun) / 3600, 1);
    collectCronLog("checking $function last " . date("Y-m-d H:i:s", $lastRun) . " now " . date("Y-m-d H:i:s", $currentTime) . "; hours diff $hoursDiff ", 'd');

    // Run if it's been more than 22 hours since the last run.
    if ($hoursDiff >= 22) {
      return TRUE;
    }

  }
  elseif ($function == 'users') {

    // showStatus("disable: ". \Drupal::state()->get('access_affinitygroup.alloc_cron_disable', false) );
    // showStatus("allw_ond: ".  \Drupal::state()->get('access_affinitygroup.alloc_cron_allow_ondemand', false) );
    // These 2 environment booleans are off by default but can be set in the
    // Constant Contact admin page.
    if (\Drupal::state()->get('access_affinitygroup.alloc_cron_disable', FALSE)) {
      return FALSE;
    }
    if (\Drupal::state()->get('access_affinitygroup.alloc_cron_allow_ondemand', FALSE)) {
      return TRUE;
    }

    if (!cCronCheckInterval) {
      // Same as allow_ondemand, can probably get rid of this.
      return TRUE;
    }

    $lastRun = \Drupal::state()->get('access_affinitygroup.crontime-u', 0);
    $hoursDiff = round(($currentTime - $lastRun) / 3600, 1);
    collectCronLog("checking $function last " . date("Y-m-d H:i:s", $lastRun) . " now " . date("Y-m-d H:i:s", $currentTime) . "; hours diff $hoursDiff ", 'd');

    // Run if it's been more than 24 hours since the last run.
    if ($hoursDiff > 24) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Update current users with their current allocations and set their cider resrouces field (allocations), and
 * add them to associated affinity groups. If user not found in database, we create it here.
 * run from cron
 * ciderName: this is the "Global Resource Id" (from CiDeR), aka "info_resource_id" from xdusage api aka "allocation"
 * Example: anvil-gpu.perdue.xsede.org
 * ciderRefNum: the entity number/ the interal id for the entity of type Access Active Resources from CiDeR
 * Example: '429'
 * variable names beginning with "xd" have to do with the info incoming from the api.
 * Every user will be added to the ACCESS Support affinity group.
 */
function updateUserAllocations() {
  global $logCronErrors;
  global $logCronInfo;
  collectCronLog('Running updateUserAllocations.', 'i');

  try {
    // get access support affinity group node for later
    $nArray = \Drupal::entityQuery('node')
                            ->condition('type', 'affinity_group')
                            ->condition('title', 'ACCESS Support')
                            ->execute();
    $accessSupportNodeId = empty($nArray) ? 0 :  array_values($nArray)[0];

    $apiBase = 'https://allocations-api.access-ci.org/acdb/xdusage';
    $requestUrl = $apiBase . '/v2/projects?active_only&not_expired';

    $path = \Drupal::service('file_system')->realpath("private://") . '/.keys/secrets.json';
    if (!file_exists($path)) {
      collectCronLog("Unable to get xsede api key.");
      return FALSE;
    }
    $secretsData = json_decode(file_get_contents($path), TRUE);
    $apiKey = $secretsData['xdusage_api_key'];
    $requestOpts = [
      'headers' => [
        'XA-API-KEY' => $apiKey,
        'XA-AGENT'   => 'xdusage',
        'XA-RESOURCE' => 'support.access-ci.org',
        'Content-Type' => 'application/json',
      ],
      'curl' => [CURLOPT_SSLVERSION => CURL_SSLVERSION_TLSv1],
    ];

    $client = new Client();
    $response = $client->request('GET', $requestUrl, $requestOpts);

    $responseJson = Json::decode((string) $response->getBody());
  }
  catch (Exception $e) {
    collectCronLog('xdusage api call: ' . $e->getMessage());
    return FALSE;
  }
  $userCount = 0;
  $newUsers = 0;
  $newCCIds = 0;
  try {
    /*
     * Api response is a list of projects. We want the user name and resource
     * from each. Users can be on many projects.
     * Compile a list of portal usernames (duplicated removed) with their
     * associated projects (duplicates removed).
     */
    $xdProjectsArray = $responseJson['result'];
    $xdAllocations = [];

    // Assemble array of users and which resources (allocations) they use, discarding duplicates.
    foreach ($xdProjectsArray as $xdProject) {

      $xdUserName = $xdProject['pi_portal_username'];
      if (array_key_exists($xdUserName, $xdAllocations)) {
        // Have user. add this rid if they don't already have in the list we are gathering for this use.
        if (array_search($xdProject['info_resource_id'], $xdAllocations[$xdUserName]) === FALSE) {
          array_push($xdAllocations[$xdUserName], $xdProject['info_resource_id']);
        }
      }
      else {
        // User not on list, so add it.
        $xdAllocations[$xdUserName] = [$xdProject['info_resource_id']];
      }
    }

    // For each user: if user does not exist, create the user. First look for the user via
    // the access version of the name, which is their portal name plus @access-ci.org tacked on
    // Once we have a user handle, whether newly created or existing,
    // for each Resource Id (allocation), find related AG. Make sure user is part of that AG.
    collectCronLog('Users from api: count ' . count($xdAllocations), 'i');

    foreach ($xdAllocations as $xdUserName => $xdUserCiderNames) {

      try {
        $userCount++;
        // If ($userCount > 100)  {kint($userCount); die();}
        $accessUserName = $xdUserName . cDevUname . '@access-ci.org';
        collectCronLog("Processing $userCount: $accessUserName", 'd');
        $userDetails = user_load_by_name($accessUserName);

        // If we already have user, make sure they are all set with the cc id.
        // @todo potentially, will  need to put in a check if they have
        // changed their email or their firstname or lastname, and change it for
        // the drual database.
        $needCCId = TRUE;
        if ($userDetails) {
          $needCCId = needsCCId($userDetails);
        }

        // Did not have the user, so create it. Ongoing, this is much the less frequent case
        // so instead of storing everyone's account info in $users, go back to incoming to find user's info in one of their projects.
        if ($userDetails === FALSE || $needCCId) {
          $xdOneUsersProjects = array_usearch($xdProjectsArray, function ($o) use ($xdUserName) {
            return $o['pi_portal_username'] === $xdUserName;
          });
          // Get just first one.
          $xdOneUsersProjects = reset($xdOneUsersProjects);

        }
        if ($userDetails === FALSE) {
          $userDetails = createUser($xdOneUsersProjects['pi_portal_username'], $xdOneUsersProjects['pi_first_name'], $xdOneUsersProjects['pi_last_name']);
          // Portal email is found and set during create user.
          $portalEmail = $userDetails->getEmail();
          if ($userDetails) {
            $newUsers++;
          }
        }
        if ($needCCId) {
          // Already had user in our DB, but still need to get the email in the api.
          $portalEmail = getEmailFromApi($xdOneUsersProjects['pi_portal_username']);
        }
        if ($needCCId && $userDetails) {
          // Either new user just created, or existing user missing constant contact id.
          if (cronAddToConstantContact($userDetails, $portalEmail, $xdOneUsersProjects['pi_first_name'], $xdOneUsersProjects['pi_last_name'])) {
            $newCCIds++;
          }
        }

        // !!(todo - Should really make a lookup table for all cider rid=>entityIds)
        // map the  incoming resource names for this user to array of the internal reference numbers
        // for comparison with those in the user's existing list of resource names
        $xdCiderRefnums = [];
        foreach ($xdUserCiderNames as $ciderName) {

          // Get a list of the corresponding entity ids for the incoming
          // this can be used to compare to the existing.
          // @todo should this be case-sensitive or not.
          $query = \Drupal::entityQuery('node');
          $refnum = $query
            ->condition('type', 'access_active_resources_from_cid')
            ->condition('field_access_global_resource_id', $ciderName)
            ->execute();

          if (empty($refnum)) {
            // collectCronLog("Not found in CiDeR active res: $ciderName ", 'd');.
          }
          else {
            array_push($xdCiderRefnums, reset($refnum));
          }
        }

        // Now we have a loaded userDetails whether existing or newly created. Check the user's Resources to see if they still match.
        // now from list of resource_id for this user, check each to see which AG they are associated with. build list of AGs for this user.
        $userCiderRefnums = [];
        $userCiderArray = $userDetails->get('field_cider_resources')->getValue();
        foreach ($userCiderArray as $userCider) {
          $userCiderRefnums[] = $userCider['target_id'];
        }

        // Is xd incoming list different from what user already has? if not, reset the user list.
        $intersect = array_intersect(array_values($xdCiderRefnums), $userCiderRefnums);

        if (count($intersect) !== count($xdCiderRefnums) || count($intersect) !== count($userCiderRefnums)) {

          collectCronLog('---updating user ciders; count new: ' . count($xdCiderRefnums) . ' was ' . count($userCiderRefnums), 'i');
          updateUserCiderList($userDetails, $xdCiderRefnums);
        }
        // Finally, check for AG membership in each AG corresponding to the ciderRefnum.
        // Gather a list of associated affinity groups (unique)
        // The Cider Refs might be associated with multiples AGs;
        // an AG has 0 to many Cider Refs.
        $agNodes = [];
        foreach ($xdCiderRefnums as $refnum) {

          $query = \Drupal::entityQuery('node');
          $agNodeIds = $query
            ->condition('type', 'affinity_group')
            ->condition('field_cider_resources', $refnum)
            ->execute();

          foreach ($agNodeIds as $id) {
            if (!in_array($id, $agNodes)) {
              $agNodes[] = $id;
            }
          }
        }
        // and, we add every user to ACCESS Support AG.
        $agNodes[] = $accessSupportNodeId;

        // Now we have agNodes, which is a list of all affinity groups having to do with the user's allocations.
        // set membership will add the user to the group unless they previously blocked automembership to the ag by leaving.
        $userBlockedArray = $userDetails->get('field_blocked_ag_tax')->getValue();

        $userBlockedAgTids = [];
        foreach ($userBlockedArray as $userBlock) {
          $userBlockedAgTids[] = $userBlock['target_id'];
        }

        foreach ($agNodes as $agNid) {
          setUserMembership($agNid, $userDetails, $userBlockedAgTids, TRUE);
        }
      }
      catch (Exception $e) {
        collectCronLog("Exception for incoming user $xdUserName  " . $e->getMessage());
      }
    } // end foreach xdAllocation (each unique returned from api)
  }
  catch (Exception $e) {
    collectCronLog("Exception while processing api results at $userCount " . $e->getMessage());
  }
  collectCronLog("Finished Allocation import. Processed: $userCount,  New users: $newUsers, CC Ids added: $newCCIds", 'i');
  return TRUE;
}

/**
 * User membership for an affinity group is stored in a per-user flag (not global) on the ag.
 * $agNid - AG node id
 * $blocklist - array of taxonomy ids for blocked ags.
 */
function setUserMembership($agNid, $userDetails, $blockList, $isJoin) {

  $ag = Node::load($agNid);
  $agTax = \Drupal::entityTypeManager()
    ->getStorage('taxonomy_term')
    ->loadByProperties(['name' => ($ag->get('title')->value)]);
  $agTax = reset($agTax);

  // For joining only, check if ag is on block list.
  if ($isJoin && in_array($agTax->id(), $blockList)) {
    collectCronLog('...user blocked ' . $agTax->id() . ' ' . $ag->get('title')->value, 'd');
    return;
  }

  $flagService = \Drupal::service('flag');
  // Replace by flag machine name.
  $flag = $flagService->getFlagById('affinity_group');

  // Check if already flagged. If not, set the join flag, and
  // call constant contact api to add to corresponding email group.
  $flagStatus = $flagService->getFlagging($flag, $agTax, $userDetails);
  if (!$flagStatus) {

    $flagService->flag($flag, $agTax, $userDetails);
    subscribeToCCList($agTax->id(), $userDetails);
    collectCronLog("...add member: " . $ag->get('title')->value . ': ' . $userDetails->get('field_user_last_name')->getString(), 'i');
  }
  else {
    // collectCronLog("...user already a member: ".$ag->get('title')->value, 'i');.
  }
}

/**
 * Reset user's cider list.
 */
function updateUserCiderList($userDetails, $ciderRefnums) {

  $userDetails->set('field_cider_resources', NULL);
  foreach ($ciderRefnums as $refnum) {
    $userDetails->get('field_cider_resources')->appendItem($refnum);
  }
  $userDetails->save();
}

/**
 *
 */
function array_usearch(array $array, callable $comparitor) {
  return array_filter(
      $array,
      function ($element) use ($comparitor) {
        if ($comparitor($element)) {
            return $element;
        }
      }
  );
}

/**
 * For use with updateUserAllocations cron.
 * create the user and call the api to get their email.
 */
function createUser($portalName, $firstName, $lastName) {
  try {

    // $portalName = $userProject['pi_portal_username'];
    $accessName = $portalName . cDevUname . '@access-ci.org';

    $uEmail = getEmailFromApi($portalName);

    $u = User::create();
    $x = $u->id();
    $u->set('status', 1);
    $u->setUsername($accessName);
    $u->setEmail($uEmail);

    $u->set('field_user_first_name', $firstName);
    $u->set('field_user_last_name', $lastName);

    $u->save();
    $y = $u->id();
    collectCronLog("User created $accessName - $uEmail ($y)", 'i');
  }
  catch (Exception $e) {
    collectCronLog("Exception createUser $portalName: " . $e->getMessage());
    $u = FALSE;
  }
  return $u;
}

/**
 *
 */
function getEmailFromApi($portalName) {
  // Get additional user details from api, bc we need the email.
  $userInfo = get_account_data_from_api($portalName);

  if ($userInfo === FALSE) {
    // Log inability to get email but continue with create.
    $uEmail = '';
    collectCronLog("Could not get user email from API, user: $portalName");
  }
  else {
    $uEmail = cDevUname . $userInfo['email'];
  }
  return $uEmail;
}

/**
 * Boolean check if user has a CC Id.
 */
function needsCCId($u) {
  $ccId = NULL;
  $fVal = $u->get('field_constant_contact_id')->getValue();
  if (!empty($fVal)) {
    $ccId = $fVal[0]['value'];
  }
  if (!empty($ccId)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Send in userdetail to check for absent cc id. If not there, attempt to add.
 * return boolean success.
 */
function cronAddToConstantContact($u, $uEmail, $firstName, $lastName) {

  $ccId = addUserToConstantContact($uEmail, $firstName, $lastName);
  if (empty($ccId)) {
    collectCronLog("Could not add user to Constant Contact:  $uEmail");
    return FALSE;
  }
  else {
    $u->set('field_constant_contact_id', $ccId);
    $u->save();
    collectCronLog("Id from Constant Contact:  $uEmail", 'i');
    return TRUE;
  }
}

/**
 * Collect problems adding user, etc  here to send as a dev alert email at end of cron
 * also used for logging both errors and status
 * we might do this in a file.
 */
function collectCronLog($msg, $logType = 'err') {
  global $logCronErrors;
  global $logCronInfo;

  if ($logType === 'err') {
    $logCronErrors[] = $msg;
    \Drupal::logger('cron_affinitygroup')->error($msg);
  }
  elseif ($logType === 'i') {
    \Drupal::logger('cron_affinitygroup')->notice($msg);
    $logCronInfo[] = $msg;
  }
  else {
    \Drupal::logger('cron_affinitygroup')->debug($msg);
  }
}

/**
 * Send an email with the collected cron errors to users with role: cyberdevs.
 * TODO: This function does not work correctly at this time.
 */
function emailDevCronLog() {

  global $logCronErrors;
  // Global $logCronInfo;.
  if (empty($logCronErrors) || count($logCronErrors) == 0) {
    return;
  }

  // Make destination list of emails of users with administrator role.
  $userIds = \Drupal::entityQuery('user')
    ->condition('status', 1)
    ->condition('roles', 'cyberdevs')
    ->execute();
  $users = User::loadMultiple($userIds);
  $toAddrs = '';
  $userCount = count($users);
  $iterate = 0;
  foreach ($users as $user) {
    $iterate++;
    $toAddrs .= $user->get('mail')->getString();
    if ($userCount != $iterate) {
      $toAddrs .= ",";
    }
  }

  $params = [];
  $params['to'] = $toAddrs;
  $body = '';
  if (!empty($logCronErrors)) {
    $body = 'ERRORS: ' . implode('\n', $logCronErrors);
  }
  // If (!empty($logCronInfo)) { $body = $body. '\nINFO: ' . implode('\n' , $logCronInfo);}.
  $params['body'] = $body;
  $params['title'] = 'ACCESS CRON: errors during xsede user + allocations import';
  $langcode = \Drupal::currentUser()->getPreferredLangcode();
  $module = 'access_affinitygroup';
  $key = 'access_affinitygroup';
  $mailManager = \Drupal::service('plugin.manager.mail');
  $result = $mailManager->mail($module, $key, $toAddrs, $langcode, $params, NULL, TRUE);
  if ($result === FALSE
    || (array_key_exists('result', $result) && !$result['result'])) {
    \Drupal::logger('cron_affinitygroup')->error("Error sending mail to " . $toAddrs);
  }
}

/**
 * Email emailText to each AG email group in ccListIds array.
 * Subject of email is emailTitle.
 * See makeNewsHTML for meaning of other arguments.
 *
 * Steps to send email campaign from Constant Contact:
 * Setup:
 * - Make a POST request to create an email campaign and campaign activities.
 * - Make a GET request to retrieve the primary_email email campaign activity.
 * Send:
 * - Make a PUT request to update the email campaign activity and add recipients.
 * - Make a POST request to schedule the email campaign activity.
 */

/**
 * Last 2 args are arrays.
 */
function emailToAffinityGroups($emailText, $emailTitle, $pubDate, $agNames, $newsUrl, $ccListIds) {

  // For CC, must be unique name for campaign.
  $campaignName = uniqid('Access-news', TRUE);
  $emailHtml = makeNewsHTML($emailText, $emailTitle, $pubDate, $agNames, $newsUrl);   // replace with next line
  // $emailHtml = ccNewsSingleHTML($emailText, $emailTitle, $pubDate, $agNames, $newsUrl);  // the new one
  $ccResponse = setupEmailCampaign($emailTitle, $emailHtml, $campaignName);

  if (!empty($ccResponse)) {
    $campaignId = $ccResponse->campaign_id;
    $campaignActivityId = $ccResponse->campaign_activities[0]->campaign_activity_id;
    sendEmailCampaign($campaignId, $campaignActivityId, $ccListIds);
  }
}

/**
 * Create the Constant Contact email campaign, which is the initial setup.
 * Nothing is sent at this point. Returns the response which included the
 * campaign id and campaign activity id needed for step leading to send.
 * campaignName must be unique to the cc account.
 */
function setupEmailCampaign($emailSubject, $emailHtml, $campaignName) {

  $postData = [
    'name' => $campaignName,
    'email_campaign_activities' => [
      [
        'format_type' => 5,
        'from_name' => 'Access Support',
        'from_email' => cAccessEmail,
        'reply_to_email' => cAccessEmail,
        'subject' => $emailSubject,
        'preheader' => $emailSubject,
        'html_content' => $emailHtml,
      ],
    ],
  ];

  // note: could include irl addr in postData if we want to change it, but don't have to as cc uses addr on record for footer address in email.
  $postData = json_encode($postData);
  $cca = new ConstantContactApi();
  $ccResponse = $cca->apiCall('/emails', $postData, 'POST');

  return $ccResponse;
}

/**
 * Take the campaign and campaign activity ids from the campaign setup api call,
 * set up the recipient lists, and finally, schedule for immediate sendoff.
 * ccListIds: array of CC email List Ids, one for each AG
 */
function sendEmailCampaign($campaignId, $campaignActivityId, $ccListIds) {
  // first, get the activity object.
  $sent = FALSE;
  $cca = new ConstantContactApi();
  $ccActivity = $cca->apiCall("/emails/activities/$campaignActivityId");

  if (!empty($ccActivity)) {

    // Update activity obj with the destination cc email lists in
    // an array with list_id from each AG group to receive news.
    $ccActivity->contact_list_ids = $ccListIds;

    $ccActivity = json_encode($ccActivity);
    $ccResponse = $cca->apiCall("/emails/activities/$campaignActivityId", $ccActivity, 'PUT');

    if (!empty($ccResponse)) {
      // finally, send it, scheduled with 0 signifying: now.
      $schedule = ['scheduled_date' => '0'];
      $schedule = json_encode($schedule);
      // @todo . This is where emails are actually sent via api call to constant contact.
      $ccResponse = $cca->apiCall("/emails/activities/$campaignActivityId/schedules", $schedule, 'POST');
      $sent = TRUE;
    }
  }
  if ($sent) {
    showStatus("News item emailed to specified affinity groups.");
  }
  else {
    showStatus("Error while trying to email news items to affinity groups.");
  }
}

// this include for constant contant wrapper html will become obsolete
include 'src/emailContent.php';
// this is the new email wrapper
include 'src/ccNewsWrapper.php';

