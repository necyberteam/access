<?php

/**
 * @file
 * Module for affinity group.
 *
 * Each affinity group (AG) has a dedicated "List" in Constant Contact, and
 * each user is a Constant Contact (CC) "Contact".
 * We add a user to CC when the user logs in, if they don't already have a
 * constant contact id stored on the user form.
 * When a user Joins or Leaves an AG, we add or remove the user from
 * the corresponding CC list.
 * When an AG is edited or created, we add the list to CC if not already done.
 * Each AG should have a 'list_id' item that was generated by CC.
 * Note: The list in Constant Contact is stored by the AG name, so relationship
 * to CC list is broken if AG name changes.
 *
 * Code in this module also implements the following:
 *  - Coordinators for Affinity Groups have their
 *    "Affinity Group Leader" role updated
 *  - Whenever an Affinity Group is saved, a taxonomy term with the same
 *    name is created.
 *
 * Note: dependency on title of 'ACCESS Support' Affinity group. Change code if
 * title changes.
 */

use Drupal\node\Entity\Node;
use Drupal\access_affinitygroup\Plugin\ConstantContactApi;

use Drupal\Component\Utility\Xss;
use Drupal\Core\Entity\EntityInterface;
use Drupal\taxonomy\Entity\Term;
use Drupal\user\Entity\User;
use Drupal\user\UserInterface;
use Drupal\views\ViewExecutable;

const cAccessEmail = "supportapiaccess@access-ci.org";

/**
 * Implements hook_entity_presave().
 * Handles either
 *  case 1) User clicked Join flag on Affinity Group:
 *    We call api to add user to corresponding email list.
 *
 *   Join and Leave AG are implemented using a drupal Flag. Each AG
 *   has a corresponding flag that can be set per-user, signifying
 *   whether the user belongs to the AG.
 *
 *  case 2) Admin user saved Affinity Group form:
 *    If the AG does not already have a list_id from CC,
 *    we call api to create the email list,
 *    update AG Leader roles for added or removed coordinators,
 *    Ensure every Affinity Group name has a corresponding taxonomy term.
 */
function access_affinitygroup_entity_presave(EntityInterface $entity) {
  $type = $entity->bundle();
  if ($type == 'affinity_group') {

    if (method_exists($entity, 'getFlaggableType')) {
      // Case 1: User did Join the AG (using the Join button or link)
      // Exit if CRON because this hook assumes there is a current user.
      if (\Drupal::state()->get('access_affinitygroup.cronrunning', FALSE)) {
        return;
      }

      // The flag sits on a taxonomy; the taxonomy id is used to find the AG node
      // which we need to build the JSON to send to api.
      $taxonomyId = $entity->get('entity_id')->getValue()[0]['value'];
      $currentUser = \Drupal::currentUser();
      $userId = $currentUser->id();
      $userDetails = User::load($userId);
      subscribeToCCList($taxonomyId, $userDetails);

      // If present, remove this AG from this user's block list.
      removeBlockedAG($taxonomyId, $userDetails);
    }
    else {
      // Case 2: Affinity group edit was saved by admin user.
      update_ag_leader_roles($entity);
      add_ag_taxonomy_term($entity);

      // If not already there, add list to constant contact.
      // get all existing lists.
      $cca = new ConstantContactApi();
      $lists = $cca->apiCall('/contact_lists ');
      if (empty($lists)) {
        return;
      }

      // Debug info: here you can see all lists CC knows about along with their List IDs
      // kint($lists);
      // look for this AG in the list of CC lists (title== listname)
      $title = $entity->getTitle();
      $list_exists = FALSE;
      foreach ($lists->lists as $list) {
        if ($list->name == $title) {
          $list_exists = TRUE;
          break;
        }
      }
      // We didn't find an email list id for this AG - make it now.
      if (!$list_exists) {
        $get_fields = $entity->getFields();
        $summary = $get_fields['body']->summary;
        // Api max is 255 characters.
        $summary = (strlen($summary) > 255) ? substr($summary, 0, 255) : $summary;
        $post_data = [
          'name' => $title,
          'favorite' => 0,
          'description' => $summary,
        ];
        $post_data = json_encode($post_data);

        // Create Constant contact list named with AG title.
        $created_list = $cca->apiCall('/contact_lists ', $post_data, 'POST');

        if (!empty($created_list)) {
          $list_id = Xss::filter($created_list->list_id);
        }

        if (!empty($list_id)) {
          $entity->set('field_list_id', $list_id);
        }
        else {
          showStatus('Bad Constant Contact list id.');
        }
      }
    }
  }
}

/**
 * Implements hook_views_pre_render().
 *
 * Used in this case to add the CiDeR resource titles & descriptions to the view.
 *
 * The affinity group view has a custom text field that drupal labeled
 * 'nothing' -- this function updates that field with html listing any associated
 * CiDeR resources, both their title & description.
 */
function access_affinitygroup_views_pre_render(ViewExecutable $view) {
  if ($view->id() == 'affinity_group' && $view->current_display == 'group') {

    foreach ($view->result as $value) {

      $cider_ids = $value->_entity->get('field_cider_resources')->getValue();
      $node_storage = \Drupal::entityTypeManager()->getStorage('node');
      $cider_text = '';

      foreach ($cider_ids as $cider_id) {
        if (array_key_exists('target_id', $cider_id)) {
          $node = $node_storage->load($cider_id['target_id']);
          $cider_text .= '<h3>' . $node->get('title')->value . '</h3><p>'
            . $node->get('body')->value . '</p>';
        }
      }

      foreach ($view->field as $id => $field) {
        if ($id == 'nothing') {
          $field->options['alter']['text'] = $cider_text;
        }
      }
    }
  }
}

/**
 * - update AG Leader roles for added or removed coordinators.
 */
function update_ag_leader_roles($entity) {
  // Get all coordinators for this AG.
  $coordinators = $entity->get('field_coordinator')->getValue();

  // Add 'affinity_group_leader' role to all coordinators.
  $coordinator_ids = [];
  foreach ($coordinators as $coordinator) {
    $coordinator_id = $coordinator['target_id'];
    $coordinator_ids[] = $coordinator_id;
    $user = User::load($coordinator_id);

    $user->addRole('affinity_group_leader');
    $user->save();
  }

  // If removing a coordinator, remove the leader role (if not a leader anywhere else)
  update_removed_ag_leader_roles($entity, $coordinator_ids);
}

/**
 *
 */
function update_removed_ag_leader_roles($entity, $coordinator_ids) {
  // Get the original list of coordinators.
  $original_coordinators = $entity->original
    ? $entity->original->get('field_coordinator')->getValue()
    : NULL;

  // Build an array of all removed coordinators.
  $removed_coordinator_ids = [];
  foreach ($original_coordinators as $original_coordinator) {
    $original_coordinator_id = $original_coordinator['target_id'];
    if (!in_array($original_coordinator_id, $coordinator_ids)) {
      $removed_coordinator_ids[] = $original_coordinator_id;

      // $msg = "user id $original_coordinator_id removed";
      // \Drupal::messenger()->addStatus($msg);
    }
  }

  // If any coordinators removed, possibly remove their leader role.
  if (count($removed_coordinator_ids)) {

    // Get all affinity group coordinators on other affinity groups.
    $storage = \Drupal::service('entity_type.manager')->getStorage('node');
    $all_affinity_groups = $storage->loadByProperties([
      'type' => 'affinity_group',
    ]);

    $all_other_coordinator_ids = [];

    foreach ($all_affinity_groups as $affinity_group) {

      if ($entity->id() == $affinity_group->id()) {
        // \Drupal::messenger()->addStatus('in possibly remove, skipping group id = ' . $entity->id());
        continue;
      }
      $coordinators = $affinity_group->get('field_coordinator')->getValue();
      foreach ($coordinators as $coordinator) {
        $all_other_coordinator_ids[] = $coordinator['target_id'];
      }
    }

    // \Drupal::messenger()->addStatus('all other ag coord ids = ' . print_r($all_other_coordinator_ids, true));
    // \Drupal::messenger()->addStatus('all removed coord ids = ' . print_r($removed_coordinator_ids, true));
    // Foreach removed coordinator,
    //    if not a coordinator on any other affinity group,
    //       remove the leader role.
    foreach ($removed_coordinator_ids as $removed_coordinator_id) {
      $user = User::load($removed_coordinator_id);
      if (!in_array($removed_coordinator_id, $all_other_coordinator_ids)) {
        $user->removeRole('affinity_group_leader');
        $user->save();
        \Drupal::messenger()->addStatus('Removed Affinity Group Leader role for ' . $user->getAccountName());
      }
      else {
        \Drupal::messenger()->addStatus('Not removing Affinity Group Leader role for ' . $user->getAccountName()
          . ' because coordinator for another Affinity Group');
      }
    }
  }
}

/**
 *
 */
function add_ag_taxonomy_term($entity) {
  $ag_title = $entity->getTitle();
  $exists = !empty(ag_taxonomy_lookup($ag_title));
  $tid = NULL;
  if ($exists) {
    $tid = array_keys(ag_taxonomy_lookup($ag_title))[0];
  }
  else {
    $tid = create_ag_taxonomy_term($ag_title);
  }

  // Set entity's field_affinity_group to new term.
  $entity->set('field_affinity_group', $tid);
}

/**
 *
 */
function ag_taxonomy_lookup($ag_title) {
  // Ok to pass null -- returns null if $ag_title is null.
  // @todo deprecated.
  $lookup = taxonomy_term_load_multiple_by_name($ag_title, 'affinity_groups');
  return $lookup;
}

/**
 *
 */
function create_ag_taxonomy_term($ag_title) {
  $term = Term::create([
    'vid' => 'affinity_groups',
    'name' => $ag_title,
  ]);
  $term->save();
  return $term->tid->value;
}

/**
 * Call CC API to add user to the email list corresponding to the entityId.
 */
function subscribeToCCList($taxonomyId, $userDetails) {
  $postJSON = makeListMembershipJSON($taxonomyId, $userDetails);
  if (empty($postJSON)) {
    showStatus("Can't add user to email list; check if user is missing Constant Contact ID.");
  }
  else {
    $cca = new ConstantContactApi();
    $ccResponse = $cca->apiCall('/activities/add_list_memberships', $postJSON, 'POST');
  }
}

/**
 * Implements hook_entity_delete().
 * * Handles either
 *   Case 1) User did Leave on Affinity Group
 *    Remove user from the email list.
 *   Case 2) Admin deleted Affinity Group
 *    Delete the corresponding CC email list.
 *
 * See notes above on presave for Join flag for Leave.
 */
function access_affinitygroup_entity_delete(EntityInterface $entity) {
  $type = $entity->bundle();
  if ($type == 'affinity_group') {

    if (method_exists($entity, 'getFlaggableType')) {

      // Case 1: User did Leave AG. This flag is related to a taxonomy; the taxonomy
      // id is used to find the AG node related to the taxonomy and then the CC
      // list_id within the node for json to send to api.
      $taxonomyId = $entity->get('entity_id')->getValue()[0]['value'];
      if (empty($taxonomyId)) {
        return;
      }

      $currentUser = \Drupal::currentUser();
      $userId = $currentUser->id();
      $userDetails = User::load($userId);

      $postJSON = makeListMembershipJSON($taxonomyId, $userDetails);
      if (!empty($postJSON)) {
        $cca = new ConstantContactApi();
        $ccResponse = $cca->apiCall('/activities/remove_list_memberships', $postJSON, 'POST');
      }
      // Put this AG on this user's block list if not already there.
      addBlockedAG($taxonomyId, $userDetails);
    }
    else {
      // Case 2: AG getting deleted.
      $title = $entity->getTitle();
      $cca = new ConstantContactApi();
      $lists = $cca->apiCall('/contact_lists');
      $list_exists = FALSE;
      foreach ($lists->lists as $list) {
        if ($list->name == $title) {
          // Constant Contact contains affinity group
          // title in list.
          $list_id = $list->list_id;
          break;
        }
      }

      if (isset($list_id)) {
        $post_data = [
          'list_id' => $list_id,
        ];
        $post_data = json_encode($post_data);
        $cca->apiCall("/contact_lists/$list_id", $list_id, 'DELETE');
      }
    }
  }
}

/**
 * User is leaving an ag; add to, if not already on, blocked list.
 */
function addBlockedAG($agTaxonomyId, $userDetails) {
  $userBlockedAgTids = [];
  $userBlockedArray = $userDetails->get('field_blocked_ag_tax')->getValue();
  foreach ($userBlockedArray as $userBlock) {
    $userBlockedAgTids[] = $userBlock['target_id'];
  }

  if (!in_array($agTaxonomyId, $userBlockedAgTids)) {
    $userDetails->get('field_blocked_ag_tax')->appendItem($agTaxonomyId);
    $userDetails->save();
  }
}

/**
 * User is joining an ag; remove if on the blocked list.
 */
function removeBlockedAG($agTaxonomyId, $userDetails) {
  $userBlockedTaxIds = [];
  // Make list minus the newly joined ag.
  $userBlockedArray = $userDetails->get('field_blocked_ag_tax')->getValue();
  $wasBlocked = FALSE;
  foreach ($userBlockedArray as $userBlock) {
    if ($userBlock['target_id'] !== $agTaxonomyId) {
      $userBlockedTaxIds[] = $userBlock['target_id'];
    }
    else {
      $wasBlocked = TRUE;
    }
  }

  // Update the user with fresh block list only if ag was on block list.
  if ($wasBlocked) {
    $userDetails->set('field_blocked_ag_tax', $userBlockedTaxIds);
    $userDetails->save();
  }
}

/**
 * Prepares json for api call that for adds or deletes CC user from
 * a CC list.  The json contains 2 CC ids: the user (contact) and the
 * list id.
 * Called from code where we have the entity id of the Join/Leave flag
 * corresponding to the Affinity Group. We use this entity id to find the
 * node (AG) containing the CC list id.
 */
function makeListMembershipJSON($flagEntityId, $userDetails) {
  $ccIdField = $userDetails->get('field_constant_contact_id')->getValue();
  if (!empty($ccIdField)) {
    $user_cc_id = $ccIdField[0]['value'];
  }

  if (empty($user_cc_id)) {
    return NULL;
  }

  // Find the AG node that stores the entity Id of the flag; that
  // is the one and only AG that corresponds to this flag.
  $query = \Drupal::entityQuery('node');
  $node_ids = $query
    ->condition('field_affinity_group', $flagEntityId)
    ->execute();

  $aval = array_values($node_ids);
  $nid = $aval[0];

  $ag = Node::load($nid);

  // Finally we can get out the CC list id stored in the AG node.
  $fieldVal = $ag->get('field_list_id')->getValue();
  if (!empty($fieldVal)) {
    $list_cc_id = $fieldVal[0]['value'];
  }

  if (empty($list_cc_id)) {
    showStatus('Missing Constant Contact List Id for this Affinity Group.');
    return NULL;
  }

  $post_data = [
    'source' => [
      'contact_ids' => [$user_cc_id],
    ],
    'list_ids' => [$list_cc_id],
  ];
  $post_data = json_encode($post_data);
  return $post_data;
}

/**
 * Implements hook_user_login().
 * Add user to Constant Contact if we don't have a CC ID stored yet.
 */
function access_affinitygroup_user_login(UserInterface $account) {
  $current_user = \Drupal::currentUser();

  $user_id = $current_user->id();
  $user_detail = User::load($user_id);

  $cca_user_id = NULL;
  $field_val = $user_detail->get('field_constant_contact_id')->getValue();
  if (!empty($field_val)) {
    $cca_user_id = $field_val[0]['value'];
  }
  // If user did not already have the CC id, try to add to CC.
  if (empty($cca_user_id)) {

    $firstName = $user_detail->get('field_user_first_name')->getString();
    $lastName = $user_detail->get('field_user_last_name')->getString();

    $cca_user_id = addUserToConstantContact($current_user->getEmail(), $firstName, $lastName);
    if (empty($cca_user_id)) {
      showStatus("Could not add user to Constant Contact.");
    }
    else {
      $user_detail->set('field_constant_contact_id', $cca_user_id);
      $user_detail->save();
    }
  }
  else {
    // This else just for debugging in early stages
    // showStatus("Login and NOT attempting add of new constant contact id.");.
  }
}

/**
 * Return the new ID if any.
 */
function addUserToConstantContact($userEmail, $firstName, $lastName) {
  $cca = new ConstantContactApi();
  $ccaUserId = $cca->addContact($firstName, $lastName, $userEmail);
  return $ccaUserId;
}

/**
 *
 */
function showStatus($logmsg) {
  \Drupal::messenger()->addStatus($logmsg);
}

/**
 * Implements hook_cron().
 * Two functions:
 * 1) Refreshes the authorization. If not run, token expires and we'll get
 * 'not authorized' return code from api calls.
 * 2) User Allocations Import
 */
function access_affinitygroup_cron() {
  try {
    \Drupal::state()->set('access_affinitygroup.cronrunning', FALSE);
    // 1. Refresh the Constant Contact Token
    if (shouldRun('token')) {
      $currentTime = \Drupal::time()->getCurrentTime();
      \Drupal::state()->set('access_affinitygroup.crontime-t', $currentTime);
      \Drupal::logger('access_affinitygroup')->notice('Running cron: token refresh' . date("Y-m-d H:i:s", $currentTime));

      $cca = new ConstantContactApi();
      $cca->newToken();
    }

    // 2. call xdusage api to get users and create/update their
    // allocations and associated affinity groups.
    if (shouldRun('users')) {
      \Drupal::state()->set('access_affinitygroup.cronrunning', TRUE);
      $currentTime = \Drupal::time()->getCurrentTime();
      \Drupal::state()->set('access_affinitygroup.crontime-u', $currentTime);
      \Drupal::logger('cron_affinitygroup')->notice('Running cron: user' . date("Y-m-d H:i:s", $currentTime));

      // @todo this will probably be $aui->startBatch();
      // $aui = new AllocationsUsersImport();
      // $aui->updateUserAllocations();
      // emailDevCronLog(); // this function needs to be fixed.
    }
  }
  catch (Exception $e) {
    \Drupal::logger('cron_affinitygroup')->notice('exception in cron test: ' . $e->getMessage());
  } finally {
    \Drupal::state()->set('access_affinitygroup.cronrunning', FALSE);
  }
}

/**
 * Test if the cron function should run: either 'token' for refresh cc token,
 * or 'users' for running the allocations api.
 * we might read from module config file in future to see if function disabled.
 */
function shouldRun($function) {

  $currentTime = \Drupal::time()->getCurrentTime();
  if ($function == 'token') {
    $lastRun = \Drupal::state()->get('access_affinitygroup.crontime-t', 0);
    $hoursDiff = round(($currentTime - $lastRun) / 3600, 1);

    // Run if it's been at least 6 hours since the last run.
    if ($hoursDiff >= 6) {
      return TRUE;
    }
  }
  elseif ($function == 'users') {

    // TEMP TEMP JUST DON'T RUN IMPORT CRON FOR NOW.
    return FALSE;
    // showStatus("disable: ". \Drupal::state()->get('access_affinitygroup.alloc_cron_disable', false) );
    // showStatus("allw_ond: ".  \Drupal::state()->get('access_affinitygroup.alloc_cron_allow_ondemand', false) );
    // These 2 environment booleans are off by default but can be set in the
    // Constant Contact admin page.
    if (\Drupal::state()->get('access_affinitygroup.alloc_cron_disable', FALSE)) {
      return FALSE;
    }
    if (\Drupal::state()->get('access_affinitygroup.alloc_cron_allow_ondemand', FALSE)) {
      return TRUE;
    }

    $lastRun = \Drupal::state()->get('access_affinitygroup.crontime-u', 0);
    $hoursDiff = round(($currentTime - $lastRun) / 3600, 1);

    // Run if it's been more than 24 hours since the last run.
    if ($hoursDiff > 24) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Boolean check if user has a CC Id.
 */
function needsCCId($u) {
  $ccId = NULL;
  $fVal = $u->get('field_constant_contact_id')->getValue();
  if (!empty($fVal)) {
    $ccId = $fVal[0]['value'];
  }
  if (!empty($ccId)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Email emailText to each AG email group in ccListIds array.
 * Subject of email is emailTitle.
 * See makeNewsHTML for meaning of other arguments.
 *
 * Steps to send email campaign from Constant Contact:
 * Setup:
 * - Make a POST request to create an email campaign and campaign activities.
 * - Make a GET request to retrieve the primary_email email campaign activity.
 * Send:
 * - Make a PUT request to update the email campaign activity and add recipients.
 * - Make a POST request to schedule the email campaign activity.
 */

/**
 * EmailText - body of email. This will be wrapped with email html template
 *  emailTitle
 *  pubDate - published date for display in email
 *  agNames - array of affinity group names for broadcast (for display in email)
 *  ccListIds - array of constant contact list ids corresponding to the affinity groups
 *  communityTemplate - which email template to use.
 *             If true, we use community template, otherwise use the access support template.
 */
function emailToAffinityGroups($emailText, $emailTitle, $pubDate, $agNames, $newsUrl, $ccListIds, $communityTemplate, $logoUrl) {

  // For CC, must be unique name for campaign.
  $campaignName = uniqid('Access News: ' . $agNames[0] . '- ' . $pubDate . ' ', FALSE);

  // Either use email template for access or community.
  if ($communityTemplate) {
    $emailHtml = ccCommunityNewsHTML($emailText, $emailTitle, $pubDate, $agNames, $newsUrl, $logoUrl);
  }
  else {
    $emailHtml = ccAccessNewsHTML($emailText, $emailTitle, $pubDate, $agNames, $newsUrl);
  }

  $ccResponse = setupEmailCampaign($emailTitle, $emailHtml, $campaignName);

  if (!empty($ccResponse)) {
    $campaignId = $ccResponse->campaign_id;
    $campaignActivityId = $ccResponse->campaign_activities[0]->campaign_activity_id;
    sendEmailCampaign($campaignId, $campaignActivityId, $ccListIds);
  }
}

/**
 * Create the Constant Contact email campaign, which is the initial setup.
 * Nothing is sent at this point. Returns the response which included the
 * campaign id and campaign activity id needed for step leading to send.
 * campaignName must be unique to the cc account.
 */
function setupEmailCampaign($emailSubject, $emailHtml, $campaignName) {

  $postData = [
    'name' => $campaignName,
    'email_campaign_activities' => [
      [
        'format_type' => 5,
        'from_name' => 'Access Support',
        'from_email' => cAccessEmail,
        'reply_to_email' => cAccessEmail,
        'subject' => $emailSubject,
        'preheader' => $emailSubject,
        'html_content' => $emailHtml,
      ],
    ],
  ];

  // note: could include irl addr in postData if we want to change it, but don't have to as cc uses addr on record for footer address in email.
  $postData = json_encode($postData);
  $cca = new ConstantContactApi();
  $ccResponse = $cca->apiCall('/emails', $postData, 'POST');

  return $ccResponse;
}

/**
 * Take the campaign and campaign activity ids from the campaign setup api call,
 * set up the recipient lists, and finally, schedule for immediate sendoff.
 * ccListIds: array of CC email List Ids, one for each AG
 */
function sendEmailCampaign($campaignId, $campaignActivityId, $ccListIds) {
  // first, get the activity object.
  $sent = FALSE;
  $cca = new ConstantContactApi();
  $ccActivity = $cca->apiCall("/emails/activities/$campaignActivityId");

  if (!empty($ccActivity)) {

    // Update activity obj with the destination cc email lists in
    // an array with list_id from each AG group to receive news.
    $ccActivity->contact_list_ids = $ccListIds;

    $ccActivity = json_encode($ccActivity);
    $ccResponse = $cca->apiCall("/emails/activities/$campaignActivityId", $ccActivity, 'PUT');

    if (!empty($ccResponse)) {
      // finally, send it, scheduled with 0 signifying: now.
      $schedule = ['scheduled_date' => '0'];
      $schedule = json_encode($schedule);
      // @todo . This is where emails are actually sent via api call to constant contact.
      $ccResponse = $cca->apiCall("/emails/activities/$campaignActivityId/schedules", $schedule, 'POST');
      $sent = TRUE;
    }
  }
  if ($sent) {
    showStatus("News item emailed to specified affinity groups.");
  }
  else {
    showStatus("Error while trying to email news items to affinity groups.");
  }
}

// This include for constant contant wrapper html will become obsolete.
include 'src/emailContent.php';
// This is the new email wrapper.
include 'src/ccNewsWrapper.php';
