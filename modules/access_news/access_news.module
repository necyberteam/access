<?php

/**
 * @file
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Datetime\DrupalDateTime;
use Drupal\node\Entity\Node;
use Drupal\user\Entity\User;
use Drupal\recurring_events\Entity\EventSeries;
use Drupal\recurring_events\Entity\EventInstance;
use Drupal\recurring_events\EventInterface;
use Drupal\recurring_events\Plugin\ComputedField\EventInstances;
use Drupal\datetime\Plugin\Field\FieldType\DateTimeItemInterface;

/**
 * Implements hook_form_alter().
 *
 * Provide custom validation for ACCESS New and Recurring Events.
 */
function access_news_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_id == 'node_access_news_edit_form' || $form_id == 'node_access_news_form' || $form_id == 'eventseries_default_add_form' || $form_id == 'eventseries_default_edit_form') {

    $form['#validate'][] = 'access_news_validate';
  }
}

/**
 * Custom validation callback.
 *
 * Require that the person adding an Affinity Group
 * is a Coordinator of that Affinity Group.
 *
 * Also, check that the Affinity Group taxonomy term exists.
 */
function access_news_validate(&$form, FormStateInterface $form_state) {
  // Require that the person saving is an Affinity Group Coordinator
  // if an Affinity Group is selected for ACCESS News.
  $user = User::load(\Drupal::currentUser()->id());
  $ag_node_array = $form_state->getValue('field_affinity_group_node');
  // Valid values are arrays with non-null 'target-id' value.
  foreach ($ag_node_array as $ag_node) {
    if (is_array($ag_node)) {
      $nid = $ag_node['target_id'];
      if ($nid) {
        $authorized = FALSE;
        $n = Node::load($nid);
        // Administrator can assign ACCESS News to any Affinity Group.
        if (in_array('administrator', \Drupal::currentUser()->getRoles())) {
          $authorized = TRUE;
        }
        else {
          // Load coordinator(s) for the Affinity Group.
          $coordinator_field = $n->get('field_coordinator');
          if ($coordinator_field) {
            $coordinators = $coordinator_field->getValue();
            foreach ($coordinators as $coordinator) {
              if ($coordinator['target_id'] == $user->get('uid')->value) {
                $authorized = TRUE;
              }
            }
          }
        }
        // Check that the Affinity Group term exists.
        $name = $n->get('title')->value;
        $vid = 'affinity-group';
        $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->loadByProperties(['name' => $name]);
        if (!$term) {
          $form_state->setErrorByName('access_news', t('The Affinity Group taxonomy term ' . $name . ' does not exist. Please contact an administrator.'));
        }
        if (!$authorized) {
          $form_state->setErrorByName('access_news', t('You are not a Coordinator for the ' . $n->get('title')->value . ' Affinity Group.'));
        }
      }
    }
  }
}

/**
 * Implements hook_node_presave().
 *
 * Set the Affinity Group taxonomy term based on the
 * Affinity Group node so people only have to select it once.
 */
function access_news_node_presave(Node $node) {
  $type = $node->bundle();
  if ($type == 'access_news') {
    update_affinity_group($node);
  }
}

/**
 * Implements hook_entity_presave().
 *
 * Set the Affinity Group taxonomy term based on the
 * Affinity Group node so people only have to select it once.
 */
function access_news_entity_presave(EntityInterface $entity) {
  $type = $entity->getEntityTypeId();
  if ($type == 'eventseries') {
    update_affinity_group($entity);
  }
}

/**
 * Set Affinity Group taxonomy terms based on the Affinity Group node field.
 */
function update_affinity_group($node) {
  $ag_node_array = $node->get('field_affinity_group_node');
  $node->set('field_affinity_group', NULL);
  foreach ($ag_node_array as $ag_node) {
    // Get the Affinity Group node.
    $nid = $ag_node->getValue()['target_id'];
    $ag = Node::load($nid);
    $name = $ag->get('title')->value;
    // Get the term with the same name as the Affinity Group.
    $vid = 'affinity-group';
    $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->loadByProperties(['name' => $name]);
    $node->get('field_affinity_group')->appendItem(array_key_first($term));
  }
}

/**
 * Implements hook_node_insert().
 *
 * Provide message that approval is required.
 */
function access_news_node_insert(Node $node) {
  $type = $node->bundle();
  if ($type == 'access_news') {
    // Send admins a message if an ACCESS News node is created
    // and needs approval for publication.
    if (!$node->isPublished()) {
      $allowed_roles = ['administrator', 'affinity_group_leader'];
      if (!in_array($allowed_roles, \Drupal::currentUser()->getRoles())) {
        $message = t('Thank you for submitting your news. Please change the state to "Ready for Review" when you would like to publish it.');
        \Drupal::messenger()->addMessage($message);
      }
    }
    else {
      // For published news: Check if broadcast to listed AGs desired, do it if so.
      affinityGroupBroadcast($node, TRUE);
    }
  }
}

/**
 * Implements hook_entity_insert().
 *
 *  * Provide message that approval is required.
 */
function access_news_entity_insert(EntityInterface $entity) {

  $type = $entity->getEntityTypeId();
  if ($type == 'eventseries') {
    if (!$entity->isPublished()) {
      $allowed_roles = ['affinity_group_leader'];
      if (!in_array($allowed_roles, \Drupal::currentUser()->getRoles())) {
        $message = t('Thank you for submitting your event. Please change the state to "Ready for Review" when you would like to publish it.');
        \Drupal::messenger()->addMessage($message);
      }
    }
    else {
      // For published event: Check if broadcast to listed AGs desired, do it if so.
      affinityGroupBroadcast($entity, FALSE);
    }
  }
}

/**
 *
 */
function access_news_entity_update(EntityInterface $node) {

  $type = $node->bundle();
  if ($type != 'access_news') {
    $type = $node->getEntityTypeId();
  }
  // @todo possible want to allow broadcast on an individual event as well.
  // if ($type == 'access_news' || $type == 'eventseries' || $type == 'eventinstance') {
  if ($type == 'access_news' || $type == 'eventseries') {

    if ($node->isPublished()) {
      affinityGroupBroadcast($node, $type);
    }
  }
}

/**
 * Send email to constant contact email list of chosen Affinity Groups
 *  if both:
 * 1) option to BroadcastToAffinityGroup is checked
 * 2) at least one affinity group specified
 *
 * Should also be in published state, but that is checked before we get here.
 * After send attempt, uncheck the broadcast option.
 * Meant to be used by both News items and Events Series
 * (TODO - event instances TDB)
 * $newsType is eventseries or access_news (or tdb: eventinstance)
 */
function affinityGroupBroadcast(EntityInterface $node, $newsType) {

  $getFields = $node->getFields();
  $broadcastArray = $getFields['field_broadcast_affinity_groups']->getValue();
  $broadcastToAGs = $broadcastArray[0]['value'];

  // Find the node ids for the AGs.  If AGs have been specified, get the
  // corresponding Constant Contact email list ids from the nodes.
  if ($broadcastToAGs) {
    $agNodes = $node->get('field_affinity_group_node');
    if (count($agNodes)) {
      $ccListIdArray = [];
      $agNames = [];

      // Collect ag name and cc email list id.
      foreach ($agNodes as $agNode) {

        $nid = $agNode->getValue()['target_id'];
        $ag = Node::load($nid);

        $name = $ag->get('title')->value;
        array_push($agNames, $name);

        $ccListId = $ag->get('field_list_id')->value;
        array_push($ccListIdArray, $ccListId);
      }

      if (!count($ccListIdArray)) {
        showStatus("Missing Constant Contact Email List Id for Affinity Group");
      }
      else {
        // Gather items to insert into the email template.
        $titleArray = $getFields['title']->getValue();
        $title = $titleArray[0]['value'];

        $newsUrl = $node->toUrl()->setAbsolute()->toString();

        // Set pubDate and body; news / eventseries different.
        if ($newsType == 'access_news') {
          $pubDateArray = $getFields['field_published_date']->getValue();
          $pubDate = $pubDateArray[0]['value'];
          $date = date_create_from_format('Y-m-d', $pubDate);
          // Reverse the date.
          $pubDate = date_format($date, 'm-d-Y');

          $bodyArray = $getFields['body']->getValue();
          $body = $bodyArray[0]['value'];
        }
        else {
          // Newstype is eventseries.
          $pubDate = NULL;

          // Body set using a custom view mode: ccemail.
          $view_builder = \Drupal::entityTypeManager()->getViewBuilder('eventseries');
          $renderArray = $view_builder->view($node);
          $body = \Drupal::service('renderer')->renderPlain($renderArray);
        }

        // Now emailing the group; set option broadcast off. If user wants to email again after
        // and edit, they will need to check the box again.
        $node->set('field_broadcast_affinity_groups', [0]);
        $node->save();
        emailToAffinityGroups($body, $title, $pubDate, $agNames, $newsUrl, $ccListIdArray);
      }
    }
  }
}
/**
 * weeklyNewsReport()
 *
 *  Roll up all the news from the past week and events for the coming month.
 *  Make html display of these items for Constant Contact email.
 *  Set up the Constant Contact campaign, but don't send it.
 */
 function weeklyNewsReport() {

  try {
    // gather all news published from 7 days ago until now.
    $currentTime = new DrupalDateTime('now');  // includes time
    $lastWeek = new DrupalDateTime('last tuesday');

    $nextMonth = new DrupalDateTime('today+1 month');
    $today = new DrupalDateTime('today');     // time is 0

    $d1 = makeQueryDateTime($lastWeek);
    $d2 = makeQueryDateTime($currentTime);
    $newsHTML = newsRangeView($d1, $d2, TRUE);
    Drupal::logger('cron_accessnews')->notice('Rolling up news from: '. $d1. ' to: '. $d2);

  // gather all upcoming events for the next month (this date to +1 month)

    $d1 = makeQueryDateTime($currentTime);
    $d2 = makeQueryDateTime($nextMonth);
    //Drupal::logger('cron_accessnews')->notice('events from: '.date('D, d M Y H:i:s e', $d1). ' to: '.date('D, d M Y H:i:s e', $d2));
    Drupal::logger('cron_accessnews')->notice('Rolling up events from: '. $d1. ' to: '. $d2);
    $eventHTML = eventsRangeView($d1, $d2, TRUE);

    // put wrapper html
    $emailHTML = makeNewsReportHTML($newsHTML, $eventHTML);

    // create constant contact campaign. this does not send it
    $ccResponse = setupEmailCampaign('ACCESS Weekly News and Events', $emailHTML);

    if (!empty($ccResponse)) {
      $campaignId = $ccResponse->campaign_id;
      $campaignActivityId = $ccResponse->campaign_activities[0]->campaign_activity_id;
    }
  } catch (Exception $e) {
    \Drupal::logger('cron_accessnews')->error('weeklyNewsReport: ' . $e->getMessage());
  }
  // todo: send email to xx saying the draft is ready
  //return($emailHTML);  // temp return for drush
  return;
}
/**
 * wrap up the news and events list with HTML for Constant Contact email
 */

function makeNewsReportHTML($news, $event) {
  $h = '<div class="access-news-rollup-email">'. $news . $event . '</div>';
  return $h;
}
/**
 * newsRangeView
 * Return html list of news in this date range.
 * Note: the date/times should have 0 for time for the end date; if not
 * the date should be +1 from needed date.
 */
function newsRangeView($fromDate, $toDate) {

  $listDisplay = '';
  try {
    $nids = \Drupal::entityQuery('node')
            ->condition('field_published_date.value', $fromDate, '>=')
            ->condition('field_published_date.value', $toDate, '<')
            ->condition('type', 'access_news')
            ->execute();

    $nodes = Node::loadMultiple($nids);
    $nCount = 0;

    foreach ($nodes as $node) {
      try {
        $nCount += 1;

        $viewBuilder = \Drupal::entityTypeManager()->getViewBuilder('node');
        $renderArray = $viewBuilder->view($node, 'alt_teaser');
        $itemDisplay = \Drupal::service('renderer')->renderPlain($renderArray);
      }
      catch (Exception $e) {
        $itemDisplay = 'Error retrieving news item: ' . $e->getMessage();
      }

      $listDisplay = $listDisplay . '<hr><br><div class="access-news-list-item">' . $itemDisplay . '</div>';
    } // end for

    $listDisplay = '<div class="access-news-rollup-list">' . $listDisplay . '</div>';
  } catch (Exception $e) {
    $listDisplay = 'Error retrieving news: ' . $e->getMessage();
  }
  return $listDisplay;
}
/**
 * eventsRangeView
 * Return html list of news in this date range.
 */
function eventsRangeView($fromDate, $toDate) {

  $listDisplay = '';
  $eCount = 0;
  try {
    $eids = \Drupal::entityQuery('eventinstance')
            ->condition('status', 1)
            ->condition('date.value', $fromDate, '>=')
            ->condition('date.value', $toDate, '<')
            ->sort('date.value', 'ASC')
            ->execute();

    $eventNodes = EventInstance::loadMultiple($eids);
    foreach ($eventNodes as $enode) {
      try {
        $eCount += 1;
        $fields = $enode->getFields();
        $titleArray = $fields['title']->getValue();
        $title = $titleArray[0]['value'];

        // get the custom view display eventinstance.email_summary
        $viewBuilder = \Drupal::entityTypeManager()->getViewBuilder('eventinstance');
        $renderArray = $viewBuilder->view($enode, 'rollup_list');
        $itemDisplay = \Drupal::service('renderer')->renderPlain($renderArray);
      }
      catch (Exception $e) {
        $itemDisplay = 'Error retrieving event item ' . $e->getMessage();
      }
      $listDisplay = $listDisplay . '<hr><br><div>' . $itemDisplay . '</div>';
    } // end for

    $listDisplay =  '<div class="access-news-rollup-list">' . $listDisplay . '</div>';
  } catch (Exception $e) {
    $listDisplay = 'Error retrieving events: ' . $e->getMessage();
  }
  return $listDisplay;
}
// pass in 24-hr UTC  time in format yyyy-mm-dd hh:mm
// ex for 3:30 pm new york time: 2022-12-31 20:30
// this will make UTC (GMT) string suitable for database queries
function makeQueryDateTime(string $dt)
{
  $date1 = new DrupalDateTime($dt, 'UTC');
  $date1->setTimezone(new \DateTimezone(DateTimeItemInterface::STORAGE_TIMEZONE));
  return( $date1->format(DateTimeItemInterface::DATETIME_STORAGE_FORMAT));
}

/**
 * Implements hook_cron().
 */
function access_news_cron() {

  try {
    if (accessNewsCronShouldRun()) {

      $currentTime = \Drupal::time()->getCurrentTime();  // ny timezone
      \Drupal::state()->set('access_news.crontime-rollupnews', $currentTime);
      weeklyNewsReport();
    }
  }
  catch (Exception $e) {
    \Drupal::logger('cron_accessnews')->error('exception: ' . $e->getMessage());
  }  finally {
  }
}
/**
  * accessNewsCronShouldRun
  * Returns true if it's time to run the news+events rollup.
  * Want to run once on tuesdays after 8 am. We assume the calling cron job runs every hour.
 */

function accessNewsCronShouldRun() {

  $currentTime = \Drupal::time()->getCurrentTime();  // in america/ny timezone
  $dayOfWeek = date('w', $currentTime);

  // 2 is Tuesday
  if ($dayOfWeek == '2') {
    $lastRun = \Drupal::state()->get('access_news.crontime-rollupnews', 0);
    $hoursDiff = round(($currentTime - $lastRun) / 3600, 1);

    // run if it hasn't been run this tuesday already
    if ($hoursDiff >= 24) {
      return TRUE;
    }
  }
  return FALSE;
}
/**
 * Implements hook_theme().
 */
function access_news_theme($existing, $type, $theme, $path): array {
  return [
    'requestnews_block' => [
      'variables' => [],
    ],
  ];
}
